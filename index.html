<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amiga Ball Juggler Demo</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #000;
        }
        canvas { 
            display: block; 
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="info">Amiga Ball Juggler Demo</div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        
        // Initialize Three.js scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000033); // Dark blue background
        
        // Create camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15);
        camera.lookAt(0, 5, 0);
        
        // Create renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Create ground
        const groundGeometry = new THREE.PlaneGeometry(100, 100);
        const groundMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x005500,  // Dark green
            roughness: 0.8
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Create checkerboard pattern
        const checkerGeometry = new THREE.PlaneGeometry(100, 100, 100, 100);
        const checkerMaterial = new THREE.MeshBasicMaterial({
            vertexColors: true
        });
        
        // Create checkerboard colors
        const positions = checkerGeometry.attributes.position;
        const colors = [];
        
        for (let i = 0; i < positions.count; i++) {
            const x = Math.floor(positions.getX(i) + 50) / 2;
            const z = Math.floor(positions.getZ(i) + 50) / 2;
            
            if ((Math.floor(x) + Math.floor(z)) % 2 === 0) {
                colors.push(0.3, 0.3, 0.3); // Dark gray
            } else {
                colors.push(0.7, 0.7, 0.7); // Light gray
            }
        }
        
        checkerGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        const checkerboard = new THREE.Mesh(checkerGeometry, checkerMaterial);
        checkerboard.rotation.x = -Math.PI / 2;
        checkerboard.position.y = -1.99;
        scene.add(checkerboard);
        
        // Create lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);
        
        // Create environment map for reflections
        const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(128);
        const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
        scene.add(cubeCamera);
        
        // Sky dome for reflection
        const skyGeometry = new THREE.SphereGeometry(100, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({
            color: 0x87CEEB,
            side: THREE.BackSide
        });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);
        
        // Create a shiny ball material with environment reflection
        const createBallMaterial = (color) => {
            return new THREE.MeshStandardMaterial({
                color: color,
                metalness: 0.8,
                roughness: 0.2,
                envMap: cubeRenderTarget.texture
            });
        };
        
        // Ball size
        const ballRadius = 0.5;
        const ballGeometry = new THREE.SphereGeometry(ballRadius, 32, 32);
        
        // Juggler configuration
        const juggler = new THREE.Group();
        scene.add(juggler);
        juggler.position.y = 0;
        
        // Head
        const head = new THREE.Mesh(ballGeometry, createBallMaterial(0xE0E0E0));
        head.position.set(0, 7, 0);
        head.castShadow = true;
        juggler.add(head);
        
        // Body parts
        const torso1 = new THREE.Mesh(ballGeometry, createBallMaterial(0xFF0000));
        torso1.position.set(0, 6, 0);
        torso1.castShadow = true;
        juggler.add(torso1);
        
        const torso2 = new THREE.Mesh(ballGeometry, createBallMaterial(0x0000FF));
        torso2.position.set(0, 5, 0);
        torso2.castShadow = true;
        juggler.add(torso2);
        
        const torso3 = new THREE.Mesh(ballGeometry, createBallMaterial(0xFFFF00));
        torso3.position.set(0, 4, 0);
        torso3.castShadow = true;
        juggler.add(torso3);
        
        // Create arms
        const leftShoulder = new THREE.Mesh(ballGeometry, createBallMaterial(0x00FF00));
        leftShoulder.position.set(-1, 6, 0);
        leftShoulder.castShadow = true;
        juggler.add(leftShoulder);
        
        const rightShoulder = new THREE.Mesh(ballGeometry, createBallMaterial(0x00FF00));
        rightShoulder.position.set(1, 6, 0);
        rightShoulder.castShadow = true;
        juggler.add(rightShoulder);
        
        const leftArm = new THREE.Mesh(ballGeometry, createBallMaterial(0xFF00FF));
        leftArm.position.set(-1.5, 5, 0);
        leftArm.castShadow = true;
        juggler.add(leftArm);
        
        const rightArm = new THREE.Mesh(ballGeometry, createBallMaterial(0xFF00FF));
        rightArm.position.set(1.5, 5, 0);
        rightArm.castShadow = true;
        juggler.add(rightArm);
        
        const leftHand = new THREE.Mesh(ballGeometry, createBallMaterial(0xE0E0E0));
        leftHand.position.set(-2, 4, 0);
        leftHand.castShadow = true;
        juggler.add(leftHand);
        
        const rightHand = new THREE.Mesh(ballGeometry, createBallMaterial(0xE0E0E0));
        rightHand.position.set(2, 4, 0);
        rightHand.castShadow = true;
        juggler.add(rightHand);
        
        // Create legs
        const leftHip = new THREE.Mesh(ballGeometry, createBallMaterial(0x00FFFF));
        leftHip.position.set(-0.7, 3, 0);
        leftHip.castShadow = true;
        juggler.add(leftHip);
        
        const rightHip = new THREE.Mesh(ballGeometry, createBallMaterial(0x00FFFF));
        rightHip.position.set(0.7, 3, 0);
        rightHip.castShadow = true;
        juggler.add(rightHip);
        
        const leftLeg = new THREE.Mesh(ballGeometry, createBallMaterial(0xFFA500));
        leftLeg.position.set(-0.7, 2, 0);
        leftLeg.castShadow = true;
        juggler.add(leftLeg);
        
        const rightLeg = new THREE.Mesh(ballGeometry, createBallMaterial(0xFFA500));
        rightLeg.position.set(0.7, 2, 0);
        rightLeg.castShadow = true;
        juggler.add(rightLeg);
        
        const leftFoot = new THREE.Mesh(ballGeometry, createBallMaterial(0x8B4513));
        leftFoot.position.set(-0.7, 1, 0);
        leftFoot.castShadow = true;
        juggler.add(leftFoot);
        
        const rightFoot = new THREE.Mesh(ballGeometry, createBallMaterial(0x8B4513));
        rightFoot.position.set(0.7, 1, 0);
        rightFoot.castShadow = true;
        juggler.add(rightFoot);
        
        // Create juggling balls
        const jugglingBalls = [];
        const ballColors = [0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF];
        
        for (let i = 0; i < 5; i++) {
            const ball = new THREE.Mesh(
                new THREE.SphereGeometry(ballRadius * 0.8, 32, 32),
                createBallMaterial(ballColors[i])
            );
            ball.castShadow = true;
            scene.add(ball);
            jugglingBalls.push(ball);
        }
        
        // Animation parameters
        const jugglingHeight = 8;
        const jugglingWidth = 3;
        const jugglingDepth = 1;
        const jugglingSpeed = 0.8;
        const jugglingPhaseOffset = 2 * Math.PI / jugglingBalls.length;
        
        // Function to calculate juggling ball positions
        function updateJugglingBalls(time) {
            for (let i = 0; i < jugglingBalls.length; i++) {
                const phase = time * jugglingSpeed + i * jugglingPhaseOffset;
                const x = Math.sin(phase) * jugglingWidth;
                
                // Create the arc motion
                const normalizedY = (phase % (2 * Math.PI)) / (2 * Math.PI);
                let y;
                
                if (normalizedY < 0.5) {
                    // Ball is in the air (parabolic arc)
                    const t = normalizedY * 2; // 0 to 1 for the upper half of the cycle
                    y = jugglingHeight * (1 - Math.pow(2 * t - 1, 2));
                } else {
                    // Ball is being held/passed between hands
                    const handHeight = 4;
                    const t = (normalizedY - 0.5) * 2; // 0 to 1 for the lower half
                    // Linear interpolation for hand movement
                    y = handHeight;
                }
                
                // Add some depth variation
                const z = Math.cos(phase) * jugglingDepth;
                
                jugglingBalls[i].position.set(x, y, z);
            }
        }
        
        // Animation variables for the juggler
        const armSwingSpeed = 2;
        const armSwingAmount = 0.3;
        const bodyBounceAmount = 0.1;
        const bodyBounceSpeed = 2;
        
        // Function to animate the juggler
        function animateJuggler(time) {
            // Body slight bounce
            const bounce = Math.sin(time * bodyBounceSpeed) * bodyBounceAmount;
            juggler.position.y = bounce;
            
            // Arm movement for juggling
            const leftArmSwing = Math.sin(time * armSwingSpeed) * armSwingAmount;
            const rightArmSwing = Math.sin(time * armSwingSpeed + Math.PI) * armSwingAmount;
            
            leftArm.position.y = 5 + leftArmSwing;
            rightArm.position.y = 5 + rightArmSwing;
            
            leftHand.position.y = 4 + leftArmSwing * 1.5;
            rightHand.position.y = 4 + rightArmSwing * 1.5;
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() / 1000;
            
            // Update environment map occasionally for performance
            if (Math.floor(time * 10) % 10 === 0) {
                juggler.visible = false;
                jugglingBalls.forEach(ball => ball.visible = false);
                cubeCamera.update(renderer, scene);
                juggler.visible = true;
                jugglingBalls.forEach(ball => ball.visible = true);
            }
            
            // Update juggling balls
            updateJugglingBalls(time);
            
            // Animate juggler
            animateJuggler(time);
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Start animation
        animate();
    </script>
</body>
</html>